ЛАБОРАТОРНАЯ РАБОТА № 2 "ПРИНЦИПЫ ВЫПОЛНЕНИЯ КОМАНД ВЕТВЛЕНИЯ, ОРГАНИЗАЦИЯ ЦИКЛОВ И ПОДПРОГРАММ"
Цель работы: изучение принципов выполнения команд ветвления, организации циклов и подпрограмм микропроцессоров с архитектурой x86

Исходное задание выглядит слежующим образом:
![изображение](https://user-images.githubusercontent.com/86686038/234201883-914a9d27-1245-47e9-8a44-1ab754a5370e.png)

Исходные данные:
X = 13DD, Y = 715F, Z = 02FE

По условию задания необходимо увеличить Х на 007D, после чего в цикле 3 раза вычесть Z из Y и присвоить к "X'"

Способ объявления цикла представлен в строке ниже, перед началом выполнения в регистр сх необходимо передать значение количества итераций цикла. cycle: loop cycle

Для того, чтобы на каждой итерации цикла менялось только одно число, необходимо добавить условие
CMP bx, cx; Условие сравнения чисел, в данном случае (3=3)
Далее после выполнения (или не выполнения) условия необходимо реализовать ветвление
JNE Next; Перенаправляет в точку Next, если в результате сравнения двух чисел оказалось, что они не равны
MOV ax, X; В случае если числа равны, то выполняется операция передачи значения в регистр ах
AND ax, D; При помощи логического умножения зануляются 3, 5, 6, 10 биты в числе X
MOV X, ax; Возвращает обновленное значение в переменую Х
JMP MyNext; Так как итерация цикла выполнена для одного числа и следующая проверка условий (которые будут неверны при данном значении cх), то переместим в конец цикла для перехода к следующей итераций

После зануления 3, 5, 6, 10 бит, новые значения X = 43796 (в двоичном коде 1010 1011 0001 0100), Y = 49542 (в двоичном коде 1100 0001 1000 0110), Z = 43909 (в двоичном коде 1010 1011 1000 0101)
'Z = 21626 (в двоичном коде 0101 0100 0111 1010) - Число с инверсией всех бит обычного числа Z. Для этого используется операция NOT cx;
Вычисляем значение формулы M = (X' & Y') - 'Z, в результате М = 11402 (в двоичном коде 0010 1100 1000 1010)

Вычислив значение М, подсчитаем количество единиц в малдших 8-ми битах.
begin:
SHR ax,1; Сдвигаем число вправо на 1 бит и сравниваем этот бит с единицей
JNC Nxt; Если бит равен 0, то переходим в конец цикла (переход к следующей итерации)
INC bx; Если значение равно единице, то счетчик прибавляет 1 к прошлому значению
Nxt:
CMP cx,dx; Если последняя итерация цикла, то необходимо выйти за его границы
JE EXQ;
loop begin

При значении М = 11402, то число единиц среди восьми младших бит равно 3 (нечетное число)
Деление позволяет проверить наличие остатка, если он есть, то количество единиц нечетное
В зависимости от четности (нечетности) единиц будет произведено следующее ветвление.
CMP dx, bx; Сравнение остатка от деления и числа 0 JE PP; Если числа равны (остатка нет), то переходим в пункт PP (P1) JNE PPP; Если числа не равны (остаток есть), то переходим в пункт PPР (P2)

В пункте P1 выполняется циклический сдвиг вправо на 6 символов при помощи операции ROR ax,6;
JMP ADRONE перенаправляет в пункт adr1

В пункте P2 выполняется операция AND с числом F1F1 (так как при исходных данных число единиц нечетное, то мы уходим в данное ветвление)
M AND F1F1 = 8320 (в двоичном коде 0010 0000 1000 0000) JMP ADRTWO перенаправляет в пункт adr2

В пункте adr1 к числу (результат циклического сдивга) прибаляется 1
В пункте adr2 к числу (результат операции AND) выполняется операция OR с числом 1021 (в двоичном коде 0000 0011

тех же значениях Х, Y перейти в пункт Р1 и далее в adr1, необходимо, чтобы Z был равен 45038

Исходный код представлен в файле CODE1.txt Результат работы программы представлен на рисунке image
About
No description, website, or topics provided.
Resources
Readme
Stars
0 stars
Watchers
1 watching
Forks
